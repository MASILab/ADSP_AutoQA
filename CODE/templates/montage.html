<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Image Montage with QA Buttons</title>
    <style>
        body {
            font-family: Arial, sans-serif;
            margin: 20px;
            background-color: #f0f8ff; /* Light blue background */
        }
        .image-container {
            display: flex;
            flex-direction: column;
            align-items: center;
            margin-bottom: 20px;
            padding: 10px;
            border: 1px solid #ccc;
            background-color: #fff;
            box-shadow: 0 0 10px rgba(0, 0, 0, 0.1);
        }
        .image-preview {
            width: 400px; /* Adjust image preview size as needed */
            height: auto;
            margin-bottom: 10px;
        }
        .image-name {
            font-weight: bold;
            text-decoration: underline;
            margin-bottom: 10px;
        }
        .qa-buttons {
            display: flex;
            justify-content: center;
            margin-top: 10px;
        }
        .qa-button {
            margin: 0 5px;
            padding: 5px 10px;
            cursor: pointer;
            background-color: #ccc; /* Gray background by default */
        }
        .qa-button.active {
            background-color: lightgreen; /* Green for Yes */
        }
        .qa-button.active.no {
            background-color: tomato; /* Red for No */
        }
        .qa-button.active.maybe {
            background-color: yellow; /* Yellow for Maybe */
        }
        .horizontal-line {
            width: 100%;
            border-top: 1px solid #ccc;
            margin-top: 20px;
            margin-bottom: 10px;
        }
        .reason-input {
            margin-top: 10px;
            padding: 5px;
            width: 100%;
            box-sizing: border-box;
        }
    </style>
</head>
<body>
    <div id="imageMontage"></div>
    <div id="counter" class="counter">0/0</div>

    <script>
        // Extract image paths from template data
        const imagePaths = JSON.parse('{{ image_paths|tojson|safe }}'); /* const imagePaths = {{ image_paths|tojson }}; */
        const clickedPath = '{{ clicked_path }}';
        const pipeline = '{{ pipeline }}';
        let currentImageIndex = 0; // Track current image index
        let isLooping = false; // Flag to track if looping is active
        let updateInterval = null; // Interval reference for automatic update

        // Function to construct the image URL
        function constructImageUrl(clickedPath, pipeline, imageName) {
            return `/datasets/${encodeURIComponent(clickedPath)}/${encodeURIComponent(pipeline)}/${encodeURIComponent(imageName)}`;
        }

        // Function to initialize the montage
        function initializeMontage() {
            const imageMontage = document.getElementById('imageMontage');
            imageMontage.innerHTML = ''; // Clear existing content

            // Create elements for current image
            const imagePath = imagePaths[currentImageIndex];
            console.log(imagePath);
            const imageName = imagePath.split('/').pop(); // Get filename from path
            console.log(imageName);

            const imageContainer = document.createElement('div');
            imageContainer.className = 'image-container';

            const imagePreview = document.createElement('img');
            imagePreview.className = 'image-preview';
            /*imagePreview.src = imagePath; // Set image source*/
            // Fetch image path dynamically from Flask endpoint
            /*fetchImage(imagePath, imagePreview);*/

            const imageUrl = constructImageUrl(clickedPath, pipeline, imageName);
            console.log('Fetching image from URL:', imageUrl);
            imagePreview.src = imageUrl;

            imageContainer.appendChild(imagePreview);

            const nameElement = document.createElement('div');
            nameElement.className = 'image-name';
            nameElement.textContent = imageName;
            imageContainer.appendChild(nameElement);

            const qaButtons = document.createElement('div');
            qaButtons.className = 'qa-buttons';

            const yesButton = createQAButton('Yes', imagePath);
            const noButton = createQAButton('No', imagePath);
            const maybeButton = createQAButton('Maybe', imagePath);

            qaButtons.appendChild(yesButton);
            qaButtons.appendChild(noButton);
            qaButtons.appendChild(maybeButton);
            imageContainer.appendChild(qaButtons);

            // Reason input box
            const reasonInput = document.createElement('input');
            reasonInput.type = 'text';
            reasonInput.className = 'reason-input';
            reasonInput.placeholder = 'Enter reason for QA status...';
            imageContainer.appendChild(reasonInput);

            imageMontage.appendChild(imageContainer);

            // Update counter
            updateCounter();

            // Add horizontal line after each image container
            const horizontalLine = document.createElement('div');
            horizontalLine.className = 'horizontal-line';
            imageMontage.appendChild(horizontalLine);
        }

        // Function to fetch image dynamically
        function fetchImage(imagePath, imgElement) {
            // Fetch image path dynamically from Flask endpoint
            fetch(`{{ url_for('serve_image', clicked_path=clicked_path, pipeline=pipeline, image_filename=imagePath) }}`)
                .then(response => {
                    if (!response.ok) {
                        throw new Error('Network response was not ok');
                    }
                    return response.blob();
                })
                .then(blob => {
                    // Set the image source once the blob is received
                    const imageUrl = URL.createObjectURL(blob);
                    imgElement.src = imageUrl;
                })
                .catch(error => {
                    console.error('Error fetching image:', error);
                });
        }

        // Function to update the counter
        function updateCounter() {
            const counterElement = document.getElementById('counter');
            counterElement.textContent = `${currentImageIndex + 1}/${imagePaths.length}`;
        }

        // Function to create a QA button
        function createQAButton(status, path) {
            const button = document.createElement('button');
            button.className = `qa-button ${status.toLowerCase()}`;
            button.textContent = status;
            if (status === 'Yes') { /* This would need to be changed to have it read the status in from the csv*/
                button.classList.add('active');
            }
            button.addEventListener('click', function() {
                // Remove active class from all buttons
                document.querySelectorAll('.qa-button').forEach(btn => {
                    btn.classList.remove('active');
                });
                // Highlight button
                button.classList.add('active');
            });
            return button;
        }

        // Function to handle keyboard events
        function handleKeyboardEvent(event) {
            switch (event.code) {
                case 'ArrowLeft':
                    navigateImage(-1); // Move to previous image
                    break;
                case 'ArrowRight':
                    navigateImage(1); // Move to next image
                    break;
                case 'Space':
                    toggleLoop(); // Toggle looping on spacebar press
                    break;
                default:
                    break;
            }
        }

        // Function to navigate images
        function navigateImage(direction) {
            currentImageIndex = (currentImageIndex + direction + imagePaths.length) % imagePaths.length;
            initializeMontage();
        }

        // Function to toggle looping
        function toggleLoop() {
            isLooping = !isLooping;
            if (isLooping) {
                updateInterval = setInterval(() => {
                    navigateImage(1); // Move to next image every 0.25 seconds
                }, 250);
            } else {
                clearInterval(updateInterval);
            }
        }

        // Event listener for keyboard events
        document.addEventListener('keydown', handleKeyboardEvent);

        // Initialize montage on page load
        initializeMontage();
    </script>
</body>
</html>
